#include "lvars.xh"
#include "string.xh"

#ifndef _INTSET_XH
#define _INTSET_XH

// set up data type

typedef datatype intSet intSet;
datatype intSet {
  iSet_Empty ();
  iSet(int, intSet*);
  iSet_Top();
};

int eqint(int i1, int i2) {
    return i1 == i2;
}

string showint(int i) {
    return show(i);
}

// helper methods for set

int isEmptyIntSet(intSet* set) {
  match (set) {
    iSet_Empty() -> {return 1;}
    _ -> {return 0;}
  }
}

int intSetHead(intSet* set) {
  match (set) {
    iSet(h, _) -> { return h; }
    _ -> { fputs("ERROR: intSetHead() called on non intSet", stderr); exit(255); }
  }
}

intSet* intSetTail(intSet* set) {
  match (set) {
    iSet(_, tl) -> { return tl; }
    _ -> { fputs("ERROR: intSetTail() called on non intSet", stderr); exit(255); }
  }
}

// returns 1 if set1 is a subset of set2, 0 otherwise

int isIntSubset(intSet* set1, intSet* set2) {
  match (set1) {
    iSet_Empty() -> {return 1;}
    iSet_Top() -> {return 0;}
    iSet(hd1, tl1) -> {
      match (set2) {
        iSet_Empty() -> {return 0;}
        iSet_Top() -> {return 0;}
        iSet(hd2, tl2) -> {
          if (hd1 == hd2) {
            return isIntSubset(tl1, tl2);
          }
          return isIntSubset(iSet(hd1, iSet_Empty()), tl2) &&
                 isIntSubset(tl1, set2);
        }
      }
    }
  }
}

// show method

string showInnerIntSet(intSet* set) {
  match (set) {
    iSet_Top() -> {return str("Error!");}
    iSet_Empty() -> {return str("");}
    iSet(hd, tl) -> {
      string result = show(hd);
      match (tl) {
        iSet_Top() -> {return str("Error!");}
        iSet_Empty() -> {return result;}
        iSet(_, _) -> {return result + ", " + show(tl);}
      }
    }
  }
}

string showIntSet(intSet* set) {
  string result = str("{");
  return showInnerIntSet(set) + str("}");
}

// leq method

int leqSet_int(intSet* set1, intSet* set2) {
  match (set1) {
    iSet_Top() -> {
      match (set2) {
        iSet_Top() -> {return 1;}
        _ -> {return 0;}
      }
    }
    _ -> {return isIntSubset(set1, set2);}
  }
}

int isInSet_int(int item, intSet* set) {
  match (set) {
    iSet_Empty() -> {return 0;}
    iSet_Top() -> {return 0;}
    iSet(hd, tl) -> {
      if (eqint(hd, item)) {
        return 1;
      }
      return isInSet_int(item, tl);
    }
  }
}

intSet* lubSet_int(intSet* set1, intSet* set2) {
  match (set1) {
    iSet_Empty() -> {return set2;}
    iSet_Top() -> {return iSet_Top();}
    iSet(hd1, tl1) -> {
      match (set2) {
        iSet_Empty() -> {return set1;}
        iSet_Top() -> {return iSet_Top();}
        iSet(_, _) -> {
          intSet* partial = lubSet_int(tl1, set2);
          match (partial) {
            iSet_Empty() -> {return iSet(hd1, iSet_Empty());}
            iSet_Top() -> {return iSet_Top();}
            iSet(_, _) -> {
              if (isInSet_int(hd1, partial)) {
                return partial;
              }
              return iSet(hd1, partial);
            }
          }
        }
      }
    }
  }
}

intSet* intSetUnion(intSet* set1, intSet* set2) {
  match (set1) {
    iSet_Empty() -> {return set2;}
    iSet(hd1, tl1) -> {
      match (set2) {
        iSet_Empty() -> {return set1;}
        iSet(hd2, tl2) -> {
          intSet* partial = intSetUnion(tl1, set2);
          if (isIntSubset(iSet(hd1, iSet_Empty()), partial)) {
            return partial;
          }
          return iSet(hd1, partial);
        }
      }
    }
  }
}

/* if make union non-recursive, can do an operation on new elements

Set_int* nodeSetUnion(Set_int* set1, Set_int* set2) {
  Set_int* result = iSet_Empty();
  Set_int* tempSet1 = set1;
  Set_int* tempSet2 = set2;
  while (!isIntEmpty(tempSet1)) {
    match (tempSet1) {
      iSet_Top() -> {return iSet_Top();}
      iSet(hd, tl) -> {
        if (!isInSet_int(hd, result)) {
          result = iSet(hd, result);
        }  
        tempSet1 = tl;
      }
    }
  }
  while (!isIntEmpty(tempSet2)) {
    match (tempSet2) {
      iSet_Top() -> {return iSet_Top();}
      iSet(hd, tl) -> {
        if (!isInSet_int(hd, result)) {
          // can do an operation here on new elements
          // i.e., put fib(hd) into a global lvar
          put(resultLvar, I(fib(hd)));
          result = iSet(hd, result);
        }  
        tempSet2 = tl;
      }
    }
  }
  return result;
}
*/

intSet* intSetMinus(intSet* set1, intSet* set2) {
  match (set1) {
    iSet_Empty() -> {return set1;}
    iSet(hd1, tl1) -> {
      if (isIntSubset(iSet(hd1, iSet_Empty()), set2)) {
         return intSetMinus(tl1, set2);
      } else {
         return iSet(hd1, intSetMinus(tl1, set2));
      }
    }
  }
}

Lattice<intSet*> * latticeint() {
  return lattice(iSet_Empty(), iSet_Top(), leqSet_int, lubSet_int, showIntSet);
}

#endif
