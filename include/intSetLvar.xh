#ifndef _INTSETLVAR_H
#define _INTSETLVAR_H

#include "int_set.h"

typedef datatype intSetLat intSetLat;
datatype intSetLat {
  iSet_Empty();
  iSet_Top();
  iSet(IntSet*);
}

// leq methods

int leqSetItr_int(IntSetItr* itr1, IntSet* set2) {
  if (intsetitr_has_next(itr1)) {
    return intset_member(set2, intsetitr_next(itr1)) && leqSetItr_int(itr1, set2);
  }
  return 1;
}

int leqSet_int(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet_Empty() -> {return 1;}
    iSet_Top() -> {
      match (set2) {
        iSet_Top() -> {return 1;}
        _ -> {return 0;}
      }
    }
    iSet(s1) -> {
      match (set2) {
        iSet_Empty() -> {return 0;}
        iSet_Top() -> {return 1;}
        iSet(s2) -> {
          IntSetItr* newitr = new_intsetitr(s1);
          int result = leqSetItr_int(newitr, s2);
          delete_intsetitr(newitr);
          return result;
        }
      }
    }
  }
}

// display methods

void displaySet_helper(IntSetItr* itr) {
  if (intsetitr_has_next(itr)) {
    int next = intsetitr_next(itr);
    if (intsetitr_has_next(itr)) {
      printf("%d, ", next);
      displaySet_helper(itr);
    }
    printf("%d", next);
  }
}

void displaySet_int(intSetLat* set) {
  match (set) {
    iSet_Empty() -> {printf("");}
    iSet_Top() -> {printf("Error!");}
    iSet(s) -> {
      printf("{");
      IntSetItr* newitr = new_intsetitr(s);
      displaySet_helper(newitr);
      delete_intsetitr(newitr);
      printf("}");
    }
  }
}

IntSet* copyIntSet(IntSet* set) {
  IntSet* copy = malloc(sizeof(IntSet));
  copy -> root = dup_intsetnode(set->root);
  copy -> negative_one_exists = set->negative_one_exists;
  return copy;
}

// lub methods

intSetLat* lubSet_int(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet_Empty() -> {return set2;}
    iSet_Top() -> {return set1;}
    iSet(s1) -> {
      match (set2) {
        iSet_Empty() -> {return set1;}
        iSet_Top() -> {return set2;}
        iSet(s2) -> {
          IntSet* copy = copyIntSet(s1);
          intset_union(copy, s2);
          return iSet(copy);
        }
      }
    }
  }
}

// free method

void freeSet_int(intSetLat* set) {
  match (set) {
    iSet_Empty() -> {free(set);}
    iSet_Top() -> {free(set);}
    iSet(s) -> {
      delete_intset(s);
      free(set);
    }
  }
}

// other methods

int putIntSet(Lvar<intSetLat*>* l, int val) {
  IntSet* new = new_intset();
  intset_insert(new, val);
  return inst _destructive_put<intSetLat*>(l, iSet(new));
}

IntSet* intSetMinus(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet(s1) -> {
      match (set2) {
        iSet(s2) -> {
          IntSet* copy = copyIntSet(s1);
          intset_minus(copy, s2);
          return copy;
        }
      }
    }
  }
}

Lattice<intSetLat*> * latticeint() {
  return lattice(iSet_Empty(), iSet_Top(), leqSet_int, lubSet_int, displaySet_int, freeSet_int);
}

#endif
