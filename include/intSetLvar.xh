#ifndef _INTSETLVAR_H
#define _INTSETLVAR_H

#include "int_set.h"

// ******************* base lattice type for our int sets *********************

typedef datatype intSetLat intSetLat;
datatype intSetLat {
  iSet_Empty();
  iSet_Top();
  iSet(IntSet*);
}

// ****************** misc. helper methods ************************************



int putIntSet(Lvar<intSetLat*>* l, int val) {
  IntSet* new = new_intset();
  intset_insert(new, val);
  return put(l, iSet(new));
}

IntSet* intSetMinus(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet(s1) -> {
      match (set2) {
        iSet(s2) -> {
          IntSet* copy = copyIntSet(s1);
          intset_minus(copy, s2);
          return copy;
        }
      }
    }
  }
}

// ***************** leq methods **********************************************

// helper to check that each set member that itr1 iterates through is a 
// member of set2

int leqSetItr_int(IntSetItr* itr1, IntSet* set2) {
  if (intsetitr_has_next(itr1)) {
    return intset_member(set2, intsetitr_next(itr1))
           && leqSetItr_int(itr1, set2);
  }
  return 1;
}

// leq, determines if set2 can be reached via set1 in the lattice

int leqSet_int(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet_Empty() -> {return 1;}
    iSet_Top() -> {
      match (set2) {
        iSet_Top() -> {return 1;}
        _ -> {return 0;}
      }
    }
    iSet(s1) -> {
      match (set2) {
        iSet_Empty() -> {return 0;}
        iSet_Top() -> {return 1;}
        iSet(s2) -> {
          IntSetItr* newitr = new_intsetitr(s1);
          int result = leqSetItr_int(newitr, s2);
          delete_intsetitr(newitr);
          return result;
        }
      }
    }
  }
}

//******************** show methods *******************************************

// iterates through a set to get string representing all members

string showSet_helper(IntSetItr* itr) {
  if (intsetitr_has_next(itr)) {
    int next = intsetitr_next(itr);
    if (intsetitr_has_next(itr)) {
      return show(next) + ", " + showSet_helper(itr);
    }
    return show(next);
  }
  return str("");
}

// shows an element of the lattice

string showSet_int(intSetLat* set) {
  match (set) {
    iSet_Empty() -> {return str("");}
    iSet_Top() -> {return str("Error!");}
    iSet(s) -> {
      IntSetItr* newitr = new_intsetitr(s);
      string result = showSet_helper(newitr);
      delete_intsetitr(newitr);
      return str("{") + result + str("}");
    }
  }
}

// ************************* lub method ***************************************

intSetLat* lubSet_int(intSetLat* set1, intSetLat* set2) {
  match (set1) {
    iSet_Empty() -> {return set2;}
    iSet_Top() -> {return set1;}
    iSet(s1) -> {
      match (set2) {
        iSet_Empty() -> {return set1;}
        iSet_Top() -> {return set2;}
        iSet(s2) -> {
          IntSet* copy = copyIntSet(s1);
          intset_union(copy, s2);
          //printf("copy: %s\n", showSet_int(iSet(copy)).text);
          return iSet(copy);
        }
      }
    }
  }
}

// ***************************** free method **********************************

void* freeSet_int(intSetLat* set) {
  match (set) {
    iSet_Empty() -> {free(set);}
    iSet_Top() -> {free(set);}
    iSet(s) -> {
      delete_intset(s);
      free(set);
    }
  }
}

// other methods


Lattice<intSetLat*> * latticeint() {
  return lattice(iSet_Empty(), iSet_Top(), leqSet_int, lubSet_int, showSet_int);
}

#endif
