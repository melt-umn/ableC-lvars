#ifndef _INT_FOLD_XH
#define _INT_FOLD_XH

#include "int.xh"

int (*map_f)();
int (*fold_g)();

Int* lubFoldInt(Int* i1, Int* i2) {
  match (i1) {
    I_Top() -> {return i1;}
    I_Bot() -> {return i2;}
    I(n1) -> {
      match (i2) {
        I_Top() -> {return i2;}
        I_Bot() -> {return i1;}
        I(n2) -> {return I(fold_g(n1, n2));}
      }
    }
  }
}

// this is just a default leq for integers,
// since applying an associative function in the lub
// doesn't really work with get(), anyway

int leqFoldInt(Int* i1, Int* i2) {
  match (i1) {
    I_Top() -> {
      match (i2) {
        I_Top() -> {return 1;}
        _ -> {return 0;}
      }
    }
    I_Bot() -> {return 1;}
    I(n1) -> {
      match (i2) {
        I_Top() -> {return 1;}
        I_Bot() -> {return 0;}
        I(n2) -> {return n1 <= n2;}
      }
    }
  }
}

int intFoldPut(Lvar<Int*>* l, int val) {
  return put (I(map_f(val))) in (l);
}

Lattice<Int*>* intFoldLattice(int (*mapFunc)(), int (*foldFunc)()) {
  map_f = mapFunc;
  fold_g = foldFunc;
  return lattice(I_Top(), leqFoldInt, lubFoldInt, showInteger, freeInteger);
}

#endif
