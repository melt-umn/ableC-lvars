#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Note that many functions are statically checked to see if
// they are called with NULL arguments, so in many cases
// we don't also have to check this dynamically

// Use #define CHECK before including lvars.xh to check against invalid cases
// but don't see error messages or exit (instead,
// silently ignore the invalid function calls and move on as much as possible)

// Use #define DEBUG to print error messages and exit should anything
// bad occur (checks same things as CHECK, but doesn't try to 
// silently continue)

// If both CHECK and DEBUG are defined, will go with the stronger DEBUG

#ifndef _LVARS_XH
#define _LVARS_XH

int _lvarCheckValue = 1;

//******************************** Lattice ************************************

template<a> struct _Lattice {
  a _bottom;         // these elements are all specified by the user
  a _top;
  int (*_leq)();
  a (* _lub)();
  void (*_show)();
  void (*_free)();
};

// to create a new lattice with the fields specified by the user

template<a>
static Lattice<a>* _newLattice(a least, a greatest, int (*leq)(),
                               a (*lub)(), void (*showMethod)(), void (*freeMethod)()) {
  Lattice<a> * l = malloc(sizeof(Lattice<a>)); 
  l->_bottom = least;
  l->_top = greatest;
  l->_leq = leq;
  l-> _lub = lub;
  l->_show = showMethod;
  l->_free = freeMethod;
  return l;
}

template<a>
static void freeLattice(Lattice<a>* lat) {
  lat->_free(lat->_bottom);
  lat->_free(lat->_top);
  free(lat);
}

//*************************** Activation set **********************************

template<a> struct _ActivationSet {
  int _size; // how big is the set array?
  a* _set;   
  int _index; // what is the next index to fill in the set array?
  Lattice<a>* _lattice;
};

// to create a new activation set, given a lattice and an initial size

template<a>
static ActivationSet<a>* _newActivationSet(Lattice<a>* l, int size) {

  #ifdef DEBUG
    if (size < 0) {
      printf("Can't create an activation set of negative size!\n");  
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ActivationSet<a> * act = malloc(sizeof(ActivationSet<a>));
  act->_size = size;
  act->_set = malloc(sizeof(a) * size);
  act->_index = 0;
  act ->_lattice = l;
  return act;
}

// to print out a given activation set (using the lattice's show method)

template<a>
static void _showActivation(ActivationSet<a>* act){
  printf("{");  
  int i = 0;
  for (; i < act->_index - 1; i++) {
    act ->_lattice->_show(act->_set[i]);
    printf(", ");
  }
  for (; i < act->_index; i++) {
    act ->_lattice->_show(act->_set[i]);
  }

  printf("}");
}

// to add a single element to an activation set

template<a>
static ActivationSet<a>* _addAct(ActivationSet<a>* act, a element) {
  if (act->_index >= act->_size) {
     inst _resizeActSet<a>(act, 2 * act->_size + 1);
  }
  act->_set[act->_index] = element;
  act->_index++;
  return act;
}

// to copy an activation set's set over to a new, bigger array of size newSize

template<a>
static int _resizeActSet(ActivationSet<a>* act, int newSize) {
  a* newSet = malloc(sizeof(a*) * newSize);
  for (int i = 0; i < act->_size; i++) {
    newSet[i] = act->_set[i];
  }
  free(act->_set);
  act->_set = newSet;
  act->_size = newSize;
  return 1;
} 

// to free an activation set and its components
template<a>
static int _freeActivation(ActivationSet<a>* act) {
  for (int i = 0; i < act->_index; i++) {
    act->_lattice->_free(act->_set[i]);
  }
  free(act->_set);
  free(act);
  return 1;
}

//****** Threshold _set******

template<a> struct _ThresholdSet {
  Lattice<a>* _lattice;
  int _size;
  int _index;
  ActivationSet<a> ** _a_sets;
};

// to build a new threshold set, given a lattice and an initial size

template<a>
static ThresholdSet<a>* _newThresholdSet(Lattice<a> * l, int size) {
  #ifdef DEBUG
    if (size < 0) {
      printf("Error: Can't create a threshold set of negative size!\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ThresholdSet<a> * t = malloc(sizeof(ThresholdSet<a>));
  t ->_lattice = l;
  t->_size = size;
  t->_index = 0;
  t->_a_sets = malloc(sizeof(ActivationSet<a>*) * size);
  return t;
}

// to check whether two activation sets are incompatible

template<a>
static int _incompat(Lattice<a> * l, ActivationSet<a> *Q, ActivationSet<a> *R) {
  #ifdef DEBUG
    if (Q -> _lattice != l || R -> _lattice != l) {
      printf("Error: The activation sets ");
      show(Q);
      printf(" and ");
      show(R);
      printf(" don't belong to the same lattice!\n");
      exit(0);
    }
  #endif

  if (Q -> _lattice != l || R -> _lattice != l) {
    return 0;
  }

  for (int i = 0; i < Q->_index; i++) {
    for (int j = 0; j < R->_index; j++) {
      a q = Q->_set[i];
      a r = R->_set[j];
      if (!(l->_leq(l->_top, l->_lub(q, r)))) {
        #ifdef DEBUG
          printf("Error: ");
          l->_show(q);
          printf(" and ");
          l->_show(r);
          printf(" are compatible, with lub ");
          l->_show(l->_lub(q, r));
          printf("!\n");
          exit(0);
        #endif
        return 0;
      }
    }
  }
  return 1;
}

// to add an activation set to a threshold set
// if the activation set is compatible with an activation set that is already
// in the threshold set, does nothing

template<a>
static ThresholdSet<a>* _addThreshold(ThresholdSet<a>* t, ActivationSet<a>* act) {
  #ifdef DEBUG
    if (t->_lattice != act->_lattice) {
      printf("Error: activation set ");
      show(act);
      printf(" and threshold set ");
      show(t);
      printf(" do not have the same lattice. \n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (t->_lattice != act->_lattice) {
      return t; //don't change t if a is not legit
    }
  #endif

  if (t->_index >= t->_size) {
     inst _resizeThresholdSet<a>(t, 2 * t->_size + 1);
  }

  #if defined(CHECK) || defined(DEBUG)
    for (int i = 0; i < t->_index; i++) {
      if (!inst _incompat<a>(t ->_lattice, t->_a_sets[i], act)) {
        return t;
      }
    }
  #endif

  t->_a_sets[t->_index] = act;
  t->_index++;
  return t;
}

// to copy a threshold set's set over to a new, bigger array of size newSize

template<a>
static int _resizeThresholdSet(ThresholdSet<a>* t, int newSize) {
 ActivationSet<a>** newSet = malloc(sizeof(ActivationSet<a>*) * newSize);
 for (int i = 0; i < t->_index; i++) {
   newSet[i] = t->_a_sets[i];
 }

 free(t->_a_sets);
 t->_a_sets= newSet;
 t->_size = newSize;
 return 1;
}

// to free a threshold set

template<a>
static int _freeThreshold(ThresholdSet<a> *t) {
  free(t->_a_sets);
  free(t);
  return 1;
}

// to free all of the activation sets in a threshold set
// note that this only makes sense if the activation sets will
// not be needed again and are not shared with other threshold sets

template<a>
void freeActSets(ThresholdSet<a>* t) {
  for (int i = 0; i < t->_index; i++) {
    freeSet(t->_a_sets[i]);
  }
} 

// to print a threshold set, using the show method of the lattice

template<a>
static void _showThreshold(ThresholdSet<a>* t){
  printf("{");
  int i = 0;
  for (; i < t->_index - 1; i++) {
    show(t->_a_sets[i]);
    printf(", ");
  }
  for (; i < t->_index; i++) {
    show(t->_a_sets[i]);
  }
  printf("}");
}

//********************************* Lvar **************************************

template<a> struct _Lvar {
  Lattice<a> * _lattice;
  a _value;
  int _frozen; // if 0, lvar is not frozen; if 1, lvar is frozen
  pthread_mutex_t _mutex;
  pthread_cond_t _cond;
};

template<a>
static void _showLvar(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  if (l->_frozen) {
    l->_lattice->_show(l->_value);
  }
  else {

    #ifdef DEBUG
      printf("Error: Can't show a lvar before it is frozen!\n");
      exit(0);
    #endif

    printf("<Lvar Value Unavailable>");
  }
  pthread_mutex_unlock(&(l->_mutex));
}

// must be used only after completely done with lvar (synced, etc)

template<a>
static void _defaultFree(a val) {
  return;
}

template<a>
static void _freeLvar(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  // note that top and bottom will be freed with lattice, not lvar
  if (l->_value != l->_lattice->_bottom && l->_value != l->_lattice->_top) {
      l->_lattice->_free(l->_value); 
  }  
  pthread_mutex_unlock(&(l->_mutex));
  free(l);
  return;
}

// returns pointer to a new lvar for a given lattice
// lvar has initial value that is the bottom element of the lattice
// lvar is initially not frozen

template<a>
static Lvar<a>* _new(Lattice<a>* l) {
  Lvar<a>* lvarNew = malloc(sizeof(Lvar<a>));
  lvarNew->_value = l-> _bottom;
  lvarNew-> _lattice = l;
  lvarNew-> _frozen = 0;
  lvarNew->_cond = (pthread_cond_t) PTHREAD_COND_INITIALIZER;
  lvarNew->_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
  return lvarNew;
}

template<a>
static Lattice<a>* getLattice(Lvar<a>* l) {
  return l->_lattice;
}

//*********************** put and get methods ***************************

// takes an lvar and a new value for that lvar, and updates the lvar's value to
// the lub of the old value and the new value
// if update would take state of lvar to top(), returns 0, otherwise 1

template<a>
static int _put(Lvar<a>* l, a newState) {

  pthread_mutex_lock(&(l->_mutex));

  if (l->_frozen) {
     #ifdef DEBUG 
        printf("Error: can't write to a frozen lvar.\n");
        exit(0);
     #endif
    pthread_mutex_unlock(&(l->_mutex));
    return 0;
  }

  a oldState = l->_value;

  // if old value is bottom, new value is newState
  if (l->_lattice->_leq(oldState, l->_lattice->_bottom)) {
    l->_value = newState;
  }
  // if the old value is top, new value is also top, and nothing changes
  else if (l->_lattice->_leq(l->_lattice->_top, oldState)) {
    // if the new state does not match our top or bottom pointer, we can free
    if (newState != l->_lattice->_bottom && newState != l->_lattice->_top) {
      l->_lattice->_free(newState); 
    }     
  }
  // if newState is bottom, new value is old value, and nothing changes
  else if (l->_lattice->_leq(newState, l->_lattice->_bottom)) {
    // if the new state does not match our top or bottom pointer, we can free
    if (newState != l->_lattice->_bottom && newState != l->_lattice->_top) {
      l->_lattice->_free(newState); 
    }  
  }
  // if newState is top, new value is also top
  else if (l->_lattice->_leq(l->_lattice->_top, newState)) {
    l->_value = l->_lattice->_top;
    l->_lattice->_free(oldState);
    // if the new state does not match our top or bottom pointer, we can free
    if (newState != l->_lattice->_bottom && newState != l->_lattice->_top) {
      l->_lattice->_free(newState); 
    }  
  }
  // if the old value is neither top nor bottom, we need to check the lub
  else {
    a newValue = l-> _lattice-> _lub(oldState, newState);
    // if the lub is top, we have an invalid put
    if (l->_lattice->_leq(l->_lattice->_top, newValue)){

      // debug mode errors out upon invalid put
      #ifdef DEBUG
        printf("Error: invalid put of ");
        l->_lattice->_show(newState);
        printf(" into lvar of value ");
        l->_lattice->_show(oldState);
        printf("\n");
        exit(0);
      #endif

      // check mode sets value of lvar to top upon invalid put
      #ifdef CHECK
        l->_value = l->_lattice->_top;
        // if the old state does not match our top or bottom pointer, we can free
        if (oldState != l->_lattice->_bottom && oldState != l->_lattice->_top) {
          l->_lattice->_free(oldState); 
        } 
        // if the new state does not match our top or bottom pointer, we can free
        if (newState != l->_lattice->_bottom && newState != l->_lattice->_top) {
          l->_lattice->_free(newState); 
        }  
      #endif
  
      // if the new value does not match our top or bottom pointer, we can free
      if (newValue != l->_lattice->_bottom && newValue != l->_lattice->_top) {
        l->_lattice->_free(newValue); 
      }  

      // if neither check nor debug mode are selected, operation does nothing
      // and returns 0
      pthread_mutex_unlock(&(l->_mutex));
      return 0;
    }

    // otherwise, we can update the value and free the old and new states
    l->_value = newValue;
    // if the old state does not match our top or bottom pointer
    // (or the new value), we can free
    if (oldState != l->_lattice->_bottom && oldState != l->_lattice->_top
        && oldState != newValue) {
      l->_lattice->_free(oldState); 
    } 
    // if the new state does not match our top or bottom pointer
    // (or the new value), we can free
    if (newState != l->_lattice->_bottom && newState != l->_lattice->_top
        && newState != newValue) {
      l->_lattice->_free(newState); 
    }  
    
  }
  pthread_mutex_unlock(&(l->_mutex));
  pthread_cond_broadcast(&(l->_cond));

  return 1;
}

// destructive version of put (doesn't free things upon put)

template<a>
static int _put_destructive(Lvar<a>* l, a newState) {

  pthread_mutex_lock(&(l->_mutex));

  if (l->_frozen) {
     #ifdef DEBUG 
        printf("Error: can't write to a frozen lvar.\n");
        exit(0);
     #endif
    pthread_mutex_unlock(&(l->_mutex));
    return 0;
  }

  a oldState = l->_value;
  a newValue = l-> _lattice-> _lub(oldState, newState);

  if (l->_lattice->_leq(l->_lattice->_top, newValue)){
    // debug mode errors out upon invalid put
    #ifdef DEBUG
      printf("Error: invalid put of ");
      l->_lattice->_show(newState);
      printf(" into lvar of value ");
      l->_lattice->_show(oldState);
      printf("\n");
      exit(0);
    #endif

    // check mode sets value of lvar to top upon invalid put
    #ifdef CHECK
      l->_value = l->_lattice->_top;
      // if the old state does not match our top or bottom pointer, we can free
      if (oldState != l->_lattice->_bottom && oldState != l->_lattice->_top) {
        l->_lattice->_free(oldState); 
      } 
      // if the new state does not match our top or bottom pointer, we can free
      if (newState != l->_lattice->_bottom && newState != l->_lattice->_top) {
        l->_lattice->_free(newState); 
      }  
      return 0;
    #endif

    if (newState != l->_lattice->_bottom && newState != l->_lattice->_top
        && newState != newValue) {
      l->_lattice->_free(newValue);
    }
    pthread_mutex_unlock(&(l->_mutex));
    return 0;
  }

  l->_value = newValue;
  pthread_mutex_unlock(&(l->_mutex));
  pthread_cond_broadcast(&(l->_cond));

  return 1;
}

// takes an lvar and a threshold set.
// if lvar's state is at or above some element in some activation set in the 
// threshold set, returns the entire activation set in question in T

template<a>
static ActivationSet<a>* _thresholdReached(Lvar<a>* l, ThresholdSet<a> * t) {
  for (int i = 0; i < t->_index; i++) {
    for (int j = 0; j < t->_a_sets[i]->_index; j++) {
      if (l-> _lattice->_leq(t->_a_sets[i]->_set[j], l->_value)) {
        return t->_a_sets[i];
      }
    }
  }
  return NULL;
}

template<a>
static ActivationSet<a>* _get(Lvar<a>* l, ThresholdSet<a> * t) {

  pthread_mutex_lock(&(l->_mutex));

  #ifdef DEBUG
    if (l->_lattice != t->_lattice) {
      printf("Error: can't get() when Lvar doesn't have same lattice as threshold set.\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (l->_lattice != t->_lattice) {
      pthread_mutex_unlock(&(l->_mutex));
      return NULL;
    }
  #endif

  ActivationSet<a>* actReached = inst _thresholdReached<a>(l, t);
  while (actReached == NULL) {
    if (l->_frozen) {
      pthread_mutex_unlock(&(l->_mutex));
      return NULL;
    }
    pthread_cond_wait(&(l->_cond), &(l->_mutex));
    actReached = inst _thresholdReached<a>(l, t);
  }
  pthread_mutex_unlock(&(l->_mutex));
  return actReached;
}

// takes an lvar and returns the exact value of the lvar as its result
// updates the lvar to be "frozen", preventing any further updates

template<a>
static a _freeze(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  l->_frozen = 1;
  a result = l->_value;
  pthread_mutex_unlock(&(l->_mutex));
  return result;
}

// ***************************** testing functions ****************************

// must specify two example elements such that the first precedes
// the second in the lattice

template<a>
int checkLeq(Lattice<a>* D, a repElemSmall, a repElemBig) { 
  int result = 1;
  if (!D->_leq(D->_bottom, D->_bottom)) {
    printf("leq(bottom, bottom) should return 1\n");
    result = 0;
  }
  if (!D->_leq(D->_top, D->_top)) {
    printf("leq(top, top) should return 1\n");
    result = 0;
  } 
  if (!D->_leq(D->_bottom, D->_top)) {
    printf("leq(bottom, top) should return 1\n");
    result = 0;
  }
  if (D->_leq(D->_top, D->_bottom)) {
    printf("leq(top, bottom) should return 0\n");
    result = 0;
  }
  if (!D->_leq(repElemSmall, repElemBig)) {
    printf("according to specified test values, leq(");
    D->_show(repElemSmall);
    printf(", ");
    D->_show(repElemBig);
    printf(") should return 1\n");
    result = 0;
  }
  return result;
}

// must specify two representative elements and their least upper bound,
// along with an equality function for the base type of the lattice

template<a>
int checkLub(Lattice<a>* D, a rep1, a rep2, a expLub, int (*eq)()) {
  int result = 1;
  if (!eq(D->_lub(D->_top, D->_top), D->_top)) {
    printf("lub(top, top) should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_bottom, D->_bottom), D->_bottom)) {
    printf("lub(bottom, bottom) should return bottom\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_top, D->_bottom), D->_top)) {
    printf("lub(top, bottom) should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_bottom, D->_top), D->_top)) {
    printf("lub(bottom, top) should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(rep1, D->_bottom), rep1)) {
    printf("lub(");
    D->_show(rep1);
    printf(", bottom) should return ");
    D->_show(rep1);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_bottom, rep1), rep1)) {
    printf("lub(bottom, ");
    D->_show(rep1);
    printf(") should return ");
    D->_show(rep1);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(rep1, D->_top), D->_top)) {
    printf("lub(");
    D->_show(rep1);
    printf(", top) should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_top, rep1), D->_top)) {
    printf("lub(top, ");
    D->_show(rep1);
    printf(") should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(rep2, D->_bottom), rep2)) {
    printf("lub(");
    D->_show(rep2);
    printf(", bottom) should return ");
    D->_show(rep2);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_bottom, rep2), rep2)) {
    printf("lub(bottom, ");
    D->_show(rep2);
    printf(") should return ");
    D->_show(rep2);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(rep2, D->_top), D->_top)) {
    printf("lub(");
    D->_show(rep2);
    printf(", top) should return top\n");
    result = 0;
  }
  if (!eq(D->_lub(D->_top, rep2), D->_top)) {
    printf("lub(top, ");
    D->_show(rep2);
    printf(") should return top\n");
    result = 0;
  } 
  if (!eq(D->_lub(rep2, rep1), expLub)) {
    printf("lub(");
    D->_show(rep2);
    printf(", "); 
    D->_show(rep1);
    printf(") should return ");
    D->_show(expLub);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(rep1, rep2), expLub)) {
    printf("lub(");
    D->_show(rep1);
    printf(", "); 
    D->_show(rep2);
    printf(") should return ");
    D->_show(expLub);
    printf("\n");
    result = 0;
  }
  return result;
}

template<a>
int checkLattice(Lattice<a>* D, a repSmall, a repBig, a expLub, int (*eq)()) {
  return inst checkLeq<a>(D, repSmall, repBig) && inst checkLub<a>(D, repSmall, repBig, expLub, eq);
}

#endif // LVARS_H_
