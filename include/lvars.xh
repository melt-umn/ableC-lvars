#include <string.xh>
#include <stdio.h>
#include <stdlib.h>
#include <gc.h>
#include <pthread.h>
#include <errno.h>
#include <sys/time.h>

// Note that many functions are statically checked to see if
// they are called with NULL arguments, so in many cases
// we don't also have to check this dynamically

// Use #define CHECK before including lvars.xh to check against invalid cases
// but don't see error messages or exit (instead,
// silently ignore the invalid function calls and move on as much as possible)

// Use #define DEBUG to print error messages and exit should anything
// bad occur (checks same things as CHECK, but doesn't try to 
// silently continue)

// If both CHECK and DEBUG are defined, will go with the stronger DEBUG

#ifndef _LVARS_XH
#define _LVARS_XH

int _lvarCheckValue = 1;

//******************************** Lattice ************************************

template<a> struct _Lattice {
  a _bottom;         // these elements are all specified by the user
  a _top;
  int (*_leq)();
  a (* _lub)();
  int (*_eq)(); 
  string (*_show)();
};

// to create a new lattice with the fields specified by the user

template<a>
static Lattice<a>* _newLattice(a least, a greatest, int (*leq)(),
                               a (*lub)(), int (*eq)(), string (*showMethod)()) {
  Lattice<a> * l = malloc(sizeof(Lattice<a>)); 
  l->_bottom = least;
  l->_top = greatest;
  l->_leq = leq;
  l-> _lub = lub;
  l->_eq = eq;
  l->_show = showMethod;
  return l;
}

//*************************** Activation set **********************************

template<a> struct _ActivationSet {
  int _size; // how big is the set array?
  a* _set;   
  int _index; // what is the next index to fill in the set array?
  Lattice<a>* _lattice;
};

// to create a new activation set, given a lattice and an initial size

template<a>
static ActivationSet<a>* _newActivationSet(Lattice<a>* l, int size) {

  #ifdef DEBUG
    if (size < 0) {
      printf("Can't create an activation set of negative size!\n");  
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ActivationSet<a> * act = malloc(sizeof(ActivationSet<a>));
  act->_size = size;
  act->_set = malloc(sizeof(a) * size);
  act->_index = 0;
  act ->_lattice = l;
  return act;
}

// to print out a given activation set (using the lattice's show method)

template<a>
static string _showActivation(ActivationSet<a>* act){
  string result = str("{");  

  int i = 0;
  for (; i < act->_index - 1; i++) {
    result += act ->_lattice->_show(act->_set[i]) + ", ";
  }
  for (; i < act->_index; i++) {
    result += act ->_lattice->_show(act->_set[i]);
  }

  return result + "}";
}

// to add a single element to an activation set

template<a>
static ActivationSet<a>* _addAct(ActivationSet<a>* act, a element) {
  if (act->_index >= act->_size) {
     inst _resizeActSet<a>(act, 2 * act->_size + 1);
  }
  act->_set[act->_index] = element;
  act->_index++;
  return act;
}

// to copy an activation set's set over to a new, bigger array of size newSize

template<a>
static int _resizeActSet(ActivationSet<a>* act, int newSize) {
  a* newSet = malloc(sizeof(a*) * newSize);
  for (int i = 0; i < act->_size; i++) {
    newSet[i] = act->_set[i];
  }
  free(act->_set);
  act->_set = newSet;
  act->_size = newSize;
  return 1;
} 

// to free an activation set and its components
template<a>
static int _freeActivation(ActivationSet<a>* act) {
  free(act->_set);
  free(act);
  return 1;
}

//****** Threshold _set******

template<a> struct _ThresholdSet {
  Lattice<a>* _lattice;
  int _size;
  int _index;
  ActivationSet<a> ** _a_sets;
};

// to build a new threshold set, given a lattice and an initial size

template<a>
static ThresholdSet<a>* _newThresholdSet(Lattice<a> * l, int size) {
  #ifdef DEBUG
    if (size < 0) {
      printf("Error: Can't create a threshold set of negative size!\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ThresholdSet<a> * t = malloc(sizeof(ThresholdSet<a>));
  t ->_lattice = l;
  t->_size = size;
  t->_index = 0;
  t->_a_sets = malloc(sizeof(ActivationSet<a>*) * size);
  return t;
}

// to check whether two activation sets are incompatible

template<a>
static int _incompat(Lattice<a> * l, ActivationSet<a> *Q, ActivationSet<a> *R) {
  #ifdef DEBUG
    if (Q -> _lattice != l || R -> _lattice != l) {
      printf("Error: The activation sets %s and %s don't belong to the same lattice!\n",
              show(Q).text, show(R).text);
      exit(0);
    }
  #endif

  if (Q -> _lattice != l || R -> _lattice != l) {
    return 0;
  }

  for (int i = 0; i < Q->_index; i++) {
    for (int j = 0; j < R->_index; j++) {
      a q = Q->_set[i];
      a r = R->_set[j];
      if (!(l->_eq(l->_lub(q, r), l->_top))) {
        #ifdef DEBUG
          printf("Error: %s and %s are compatible, with lub %s!\n",
                 l->_show(q).text, l->_show(r).text, l->_show(l->_lub(q, r)).text);
          exit(0);
        #endif
        return 0;
      }
    }
  }
  return 1;
}

// to add an activation set to a threshold set
// if the activation set is compatible with an activation set that is already
// in the threshold set, does nothing

template<a>
static ThresholdSet<a>* _addThreshold(ThresholdSet<a>* t, ActivationSet<a>* act) {
  #ifdef DEBUG
    if (t->_lattice != act->_lattice) {
      printf("Error: activation set %s and threshold set %s do not have the same lattice. \n",
             show(act).text, show(t).text);
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (t->_lattice != act->_lattice) {
      return t; //don't change t if a is not legit
    }
  #endif

  if (t->_index >= t->_size) {
     inst _resizeThresholdSet<a>(t, 2 * t->_size + 1);
  }

  #if defined(CHECK) || defined(DEBUG)
    for (int i = 0; i < t->_index; i++) {
      if (!inst _incompat<a>(t ->_lattice, t->_a_sets[i], act)) {
        return t;
      }
    }
  #endif

  t->_a_sets[t->_index] = act;
  t->_index++;
  return t;
}

// to copy a threshold set's set over to a new, bigger array of size newSize

template<a>
static int _resizeThresholdSet(ThresholdSet<a>* t, int newSize) {
 ActivationSet<a>** newSet = malloc(sizeof(ActivationSet<a>*) * newSize);
 for (int i = 0; i < t->_index; i++) {
   newSet[i] = t->_a_sets[i];
 }

 free(t->_a_sets);
 t->_a_sets= newSet;
 t->_size = newSize;
 return 1;
}

// to free a threshold set and all of its activation sets

template<a>
static int _freeThreshold(ThresholdSet<a> *t) {
  free(t->_a_sets);
  free(t);
  return 1;
}

// to print a threshold set, using the show method of the lattice

template<a>
static string _showThreshold(ThresholdSet<a>* t){
  string result = str("{");
  int i = 0;
  for (; i < t->_index - 1; i++) {
    result += show(t->_a_sets[i]) + ", ";
  }
  for (; i < t->_index; i++) {
    result += show(t->_a_sets[i]);
  }
  return result + "}";
}

//********************************* Lvar **************************************

template<a> struct _Lvar {
  Lattice<a> * _lattice;
  a _value;
  int _frozen; // if 0, lvar is not frozen; if 1, lvar is frozen
  ThresholdSet<a> * _threshold;
  pthread_mutex_t _mutex;
  pthread_cond_t _cond;
};

template<a>
static string _showLvar(Lvar<a>* l) {
  if (l->_frozen) {
    return l->_lattice->_show(l->_value);
  }

  #ifdef DEBUG
    printf("Error: Can't show a lvar before it is frozen!\n");
    exit(0);
  #endif

  return str("<Lvar Value Unavailable>");
}

// returns pointer to a new lvar for a given lattice
// lvar has initial value that is the bottom element of the lattice
// lvar is initially not frozen

template<a>
static Lvar<a>* _new(Lattice<a>* l) {
  Lvar<a>* lvarNew = malloc(sizeof(Lvar<a>));
  lvarNew->_value = l-> _bottom;
  lvarNew-> _lattice = l;
  lvarNew-> _frozen = 0;
  lvarNew->_cond = (pthread_cond_t) PTHREAD_COND_INITIALIZER;
  lvarNew->_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
  return lvarNew;
}

//*********************** put and get methods ***************************

// takes an lvar and a new value for that lvar, and updates the lvar's value to
// the lub of the old value and the new value
// if update would take state of lvar to top(), returns 0, otherwise 1

template<a>
static int _put(Lvar<a>* l, a newState) {

  pthread_mutex_lock(&(l->_mutex));

  if (l->_frozen) {
     #ifdef DEBUG 
        printf("Error: can't write to a frozen lvar.\n");
        exit(0);
     #endif
    pthread_mutex_unlock(&(l->_mutex));
    return 0;
  }

  a oldState = l->_value;
  a newValue = l-> _lattice-> _lub(oldState, newState);

  if (l-> _lattice->_eq(l->_lattice->_top, newValue)){
      #ifdef DEBUG
        printf("Error: invalid put of %s into lvar of value %s\n",
               l->_lattice->_show(newState).text, l->_lattice->_show(oldState).text);
        exit(0);
      #endif

      #ifdef CHECK
        pthread_mutex_unlock(&(l->_mutex));
        return 0;
      #endif
  }
  l->_value = newValue;

  pthread_mutex_unlock(&(l->_mutex));
  pthread_cond_broadcast(&(l->_cond));

  return 1;
}

// takes an lvar and a threshold set.
// if lvar's state is at or above some element in some activation set in the 
// threshold set, returns the entire activation set in question in T

template<a>
static ActivationSet<a>* _thresholdReached(Lvar<a>* l, ThresholdSet<a> * t) {
  for (int i = 0; i < t->_index; i++) {
    for (int j = 0; j < t->_a_sets[i]->_index; j++) {
      if (l-> _lattice->_leq(t->_a_sets[i]->_set[j], l->_value)) {
        return t->_a_sets[i];
      }
    }
  }
  return NULL;
}

template<a>
static ActivationSet<a>* _get(Lvar<a>* l, ThresholdSet<a> * t) {

  int timeInMs = 10000;

  struct timeval tv;
  struct timespec ts;

  gettimeofday(&tv, NULL);
  ts.tv_sec = time(NULL) + timeInMs / 1000;
  ts.tv_nsec = tv.tv_usec * 1000 + 1000 * 1000 * (timeInMs % 1000);
  ts.tv_sec += ts.tv_nsec / (1000 * 1000 * 1000);
  ts.tv_nsec %= (1000 * 1000 * 1000);

  pthread_mutex_lock(&(l->_mutex));

  #ifdef DEBUG
    if (l->_lattice != t->_lattice) {
      printf("Error: can't get() when Lvar doesn't have same lattice as threshold set.\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (l->_lattice != t->_lattice) {
      pthread_mutex_unlock(&(l->_mutex));
      return NULL;
    }
  #endif

  ActivationSet<a>* actReached = inst _thresholdReached<a>(l, t);
  while (actReached == NULL) {
    int n = pthread_cond_timedwait(&(l->_cond), &(l->_mutex), &ts);
    if (n == ETIMEDOUT) {
      pthread_mutex_unlock(&(l->_mutex));
      printf("Get timed out.\n");
      return NULL;
    }
    //pthread_cond_wait(&(l->_cond), &(l->_mutex));
    actReached = inst _thresholdReached<a>(l, t);
  }
  pthread_mutex_unlock(&(l->_mutex));
  return actReached;
}

// takes an lvar and returns the exact value of the lvar as its result
// updates the lvar to be "frozen", preventing any further updates

template<a>
static a _freeze(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  l->_frozen = 1;
  a result = l->_value;
  pthread_mutex_unlock(&(l->_mutex));
  return result;
}

#endif // LVARS_H_
