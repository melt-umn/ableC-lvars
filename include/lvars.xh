#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Note that many functions are statically checked to see if
// they are called with NULL arguments, so in many cases
// we don't also have to check this dynamically

// Use #define CHECK before including lvars.xh to check against invalid cases
// but don't see error messages or exit (instead,
// silently ignore the invalid function calls and move on as much as possible)

// Use #define DEBUG to print error messages and exit should anything
// bad occur (checks same things as CHECK, but doesn't try to 
// silently continue)

// If both CHECK and DEBUG are defined, will go with the stronger DEBUG

#ifndef _LVARS_XH
#define _LVARS_XH

int _lvarCheckValue = 1;

//******************************** Lattice ************************************

template<a> struct _Value {
  a _val;
  int _top;
  int _bot;
};

template<a>
static Value<a>* _newValue(a val) {
  Value<a>* newVal = malloc(sizeof(Value<a>));
  newVal->_val = val;
  newVal->_top = 0;
  newVal->_bot = 0;
  return newVal;
}

template<a>
static Value<a>* _newTop() {
  Value<a>* newVal = malloc(sizeof(Value<a>));
  newVal->_top = 1;
  newVal->_bot = 0;
  return newVal;
}

template<a>
static Value<a>* _newBot() {
  Value<a>* newVal = malloc(sizeof(Value<a>));
  newVal->_top = 0;
  newVal->_bot = 1;
  return newVal;
}

template<a>
static int _isTop(Value<a>* val) {
  return val->_top;
}

template<a> struct _Lattice {
  int (*_leq)(a, a);
  Value<a>* (* _lub)(a, a);
  void (*_display)(a);
  void (*_free)(a);
};

// to create a new lattice with the fields specified by the user

template<a>
static Lattice<a>* _newLattice(int (*leqFunc)(a, a),
                   Value<a>* (*lub)(a, a), void (*displayMethod)(a),
                   void (*freeMethod)(a)) {
  Lattice<a> * l = malloc(sizeof(Lattice<a>)); 
  l->_leq = leqFunc;
  l-> _lub = lub;
  l->_display = displayMethod;
  l->_free = freeMethod;
  return l;
}

template<a>
static void _freeLattice(Lattice<a>* lat) {
  free(lat);
}

//*************************** Activation set **********************************

template<a> struct _ActivationSet {
  int _size; // how big is the set array?
  a* _set;   
  int _index; // what is the next index to fill in the set array?
  Lattice<a>* _lattice;
};

// to create a new activation set, given a lattice and an initial size

template<a>
static ActivationSet<a>* _newActivationSet(Lattice<a>* l, int size) {

  #ifdef DEBUG
    if (size < 0) {
      printf("Can't create an activation set of negative size!\n");  
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ActivationSet<a> * act = malloc(sizeof(ActivationSet<a>));
  act->_size = size;
  act->_set = malloc(sizeof(a) * size);
  act->_index = 0;
  act ->_lattice = l;
  return act;
}

// to print out a given activation set (using the lattice's display method)

template<a>
static void _displayActivation(ActivationSet<a>* act){
  printf("{");  
  int i = 0;
  for (; i < act->_index - 1; i++) {
    act ->_lattice->_display(act->_set[i]);
    printf(", ");
  }
  for (; i < act->_index; i++) {
    act ->_lattice->_display(act->_set[i]);
  }

  printf("}");
}

// to add a single element to an activation set

template<a>
static ActivationSet<a>* _addAct(ActivationSet<a>* act, a element) {
  if (act->_index >= act->_size) {
     inst _resizeActSet<a>(act, 2 * act->_size + 1);
  }
  act->_set[act->_index] = element;
  act->_index++;
  return act;
}

// to copy an activation set's set over to a new, bigger array of size newSize

template<a>
static int _resizeActSet(ActivationSet<a>* act, int newSize) {
  a* newSet = malloc(sizeof(a*) * newSize);
  for (int i = 0; i < act->_size; i++) {
    newSet[i] = act->_set[i];
  }
  free(act->_set);
  act->_set = newSet;
  act->_size = newSize;
  return 1;
} 

// to free an activation set and its components
template<a>
static int _freeActivation(ActivationSet<a>* act) {
  for (int i = 0; i < act->_index; i++) {
    act->_lattice->_free(act->_set[i]);
  }
  free(act->_set);
  free(act);
  return 1;
}

//****** Threshold set******

template<a> struct _ThresholdSet {
  Lattice<a>* _lattice;
  int _size;
  int _index;
  ActivationSet<a> ** _a_sets;
};

// to build a new threshold set, given a lattice and an initial size

template<a>
static ThresholdSet<a>* _newThresholdSet(Lattice<a> * l, int size) {
  #ifdef DEBUG
    if (size < 0) {
      printf("Error: Can't create a threshold set of negative size!\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (size < 0) {
      size = 0;
    }
  #endif

  ThresholdSet<a> * t = malloc(sizeof(ThresholdSet<a>));
  t ->_lattice = l;
  t->_size = size;
  t->_index = 0;
  t->_a_sets = malloc(sizeof(ActivationSet<a>*) * size);
  return t;
}

// to check whether two activation sets are incompatible

template<a>
static int _incompat(Lattice<a> * l, ActivationSet<a> *Q, ActivationSet<a> *R) {
  #ifdef DEBUG
    if (Q -> _lattice != l || R -> _lattice != l) {
      printf("Error: The activation sets ");
      display(Q);
      printf(" and ");
      display(R);
      printf(" don't belong to the same lattice!\n");
      exit(0);
    }
  #endif

  if (Q -> _lattice != l || R -> _lattice != l) {
    return 0;
  }

  for (int i = 0; i < Q->_index; i++) {
    for (int j = 0; j < R->_index; j++) {
      a q = Q->_set[i];
      a r = R->_set[j];
      if (!l->_lub(q, r)->_top) {
        #ifdef DEBUG
          printf("Error: ");
          l->_display(q);
          printf(" and ");
          l->_display(r);
          printf(" are compatible, with lub ");
          l->_display(l->_lub(q, r)->_val);
          printf("!\n");
          exit(0);
        #endif
        return 0;
      }
    }
  }
  return 1;
}

// to add an activation set to a threshold set
// if the activation set is compatible with an activation set that is already
// in the threshold set, does nothing

template<a>
static ThresholdSet<a>* _addThreshold(ThresholdSet<a>* t, ActivationSet<a>* act) {
  #ifdef DEBUG
    if (t->_lattice != act->_lattice) {
      printf("Error: activation set ");
      display(act);
      printf(" and threshold set ");
      display(t);
      printf(" do not have the same lattice. \n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (t->_lattice != act->_lattice) {
      return t; //don't change t if a is not legit
    }
  #endif

  if (t->_index >= t->_size) {
     inst _resizeThresholdSet<a>(t, 2 * t->_size + 1);
  }

  #if defined(CHECK) || defined(DEBUG)
    for (int i = 0; i < t->_index; i++) {
      if (!inst _incompat<a>(t ->_lattice, t->_a_sets[i], act)) {
        return t;
      }
    }
  #endif

  t->_a_sets[t->_index] = act;
  t->_index++;
  return t;
}

// to copy a threshold set's set over to a new, bigger array of size newSize

template<a>
static int _resizeThresholdSet(ThresholdSet<a>* t, int newSize) {
 ActivationSet<a>** newSet = malloc(sizeof(ActivationSet<a>*) * newSize);
 for (int i = 0; i < t->_index; i++) {
   newSet[i] = t->_a_sets[i];
 }

 free(t->_a_sets);
 t->_a_sets= newSet;
 t->_size = newSize;
 return 1;
}

// to free a threshold set

template<a>
static int _freeThreshold(ThresholdSet<a> *t) {
  free(t->_a_sets);
  free(t);
  return 1;
}

// to free all of the activation sets in a threshold set
// note that this only makes sense if the activation sets will
// not be needed again and are not shared with other threshold sets

template<a>
static void _freeActSets(ThresholdSet<a>* t) {
  for (int i = 0; i < t->_index; i++) {
    freeSet(t->_a_sets[i]);
  }
} 

// to print a threshold set, using the display method of the lattice

template<a>
static void _displayThreshold(ThresholdSet<a>* t){
  printf("{");
  int i = 0;
  for (; i < t->_index - 1; i++) {
    display(t->_a_sets[i]);
    printf(", ");
  }
  for (; i < t->_index; i++) {
    display(t->_a_sets[i]);
  }
  printf("}");
}

//********************************* Lvar **************************************

template<a> struct _Lvar {
  Lattice<a> * _lattice;
  Value<a>* _value;
  int _frozen; // if 0, lvar is not frozen; if 1, lvar is frozen
  pthread_mutex_t _mutex;
  pthread_cond_t _cond;
};

template<a>
static void _displayLvar(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  if (l->_frozen) {
    if (!l->_value->_bot) {
      l->_lattice->_display(l->_value->_val);
    }
  }
  else {
    #ifdef DEBUG
      printf("Error: Can't display a lvar before it is frozen!\n");
      exit(0);
    #endif

    printf("<Lvar Value Unavailable>");
  }
  pthread_mutex_unlock(&(l->_mutex));
}

// must be used only after completely done with lvar (synced, etc)

template<a>
static void _defaultFree(a val) {
  return;
}

template<a>
static void _freeLvar(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  // note that top and bottom will be freed with lattice, not lvar
  if (!l->_value->_bot) {
    l->_lattice->_free(l->_value->_val);
    free(l->_value);
  }
  pthread_mutex_unlock(&(l->_mutex));
  free(l);
  return;
}

// returns pointer to a new lvar for a given lattice
// lvar has initial value that is the bottom element of the lattice
// lvar is initially not frozen

template<a>
static Lvar<a>* _new(Lattice<a>* l) {
  Lvar<a>* lvarNew = malloc(sizeof(Lvar<a>)); 
  lvarNew->_value = inst _newBot<a>();
  lvarNew-> _lattice = l;
  lvarNew-> _frozen = 0;
  lvarNew->_cond = (pthread_cond_t) PTHREAD_COND_INITIALIZER;
  lvarNew->_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
  return lvarNew;
}

template<a>
static Lattice<a>* _getLattice(Lvar<a>* l) {
  return l->_lattice;
}

//*********************** put and get methods ***************************

// takes an lvar and a new value for that lvar, and updates the lvar's value to
// the lub of the old value and the new value
// if update would take state of lvar to top(), returns 0, otherwise 1

template<a>
static void _put(Lvar<a>* l, a newState) {

  pthread_mutex_lock(&(l->_mutex));

  if (l->_frozen) { 
    printf("Error: can't write to a frozen lvar.\n");
    exit(0);
  }
  if (l->_value->_bot) {
    l->_value = value(newState);
  } 
  else {
    a oldState = l->_value->_val;
    Value<a>* newValue = l->_lattice->_lub(oldState, newState);
    // if the lub is top, we have an invalid put
    if (newValue->_top){
      printf("Error: invalid put of ");
      l->_lattice->_display(newState);
      printf(" into lvar of value ");
      l->_lattice->_display(oldState);
      printf("\n");
      exit(0);
    }
    // otherwise, we can update the value and free the old and new states
    l->_value = newValue;
    // if the old state does not match our top or bottom pointer
    // (or the new value), we can free
    if (oldState != newValue->_val) {
      l->_lattice->_free(oldState); 
    } 
    // if the new state does not match our top or bottom pointer
    // (or the new value), we can free
    if (newState != newValue->_val) {
      l->_lattice->_free(newState); 
    }   
  }
  pthread_mutex_unlock(&(l->_mutex));
  pthread_cond_broadcast(&(l->_cond));
}

// destructive version of put (doesn't free things upon put)

template<a>
static void _put_destructive(Lvar<a>* l, a newState) {

  pthread_mutex_lock(&(l->_mutex));

  if (l->_frozen) {
    printf("Error: can't write to a frozen lvar.\n");
    exit(0);
  }

  if (l->_value->_bot) {
    l->_value = value(newState);
    pthread_mutex_unlock(&(l->_mutex));
    pthread_cond_broadcast(&(l->_cond));
  } 

  else {
    a oldState = l->_value->_val;
    Value<a>* newValue = l-> _lattice-> _lub(oldState, newState);

    if (newValue->_top){
      printf("Error: invalid put of ");
      l->_lattice->_display(newState);
      printf(" into lvar of value ");
      l->_lattice->_display(oldState);
      printf("\n");
      exit(0);
    } 

    l->_value = newValue;
    pthread_mutex_unlock(&(l->_mutex));
    pthread_cond_broadcast(&(l->_cond));

  }
}

// takes an lvar and a threshold set.
// if lvar's state is at or above some element in some activation set in the 
// threshold set, returns the entire activation set in question in T

template<a>
static ActivationSet<a>* _thresholdReached(Lvar<a>* l, ThresholdSet<a> * t) {
  if (l->_value->_bot) {
    return NULL;
  }
  for (int i = 0; i < t->_index; i++) {
    for (int j = 0; j < t->_a_sets[i]->_index; j++) {
      if (l-> _lattice->_leq(t->_a_sets[i]->_set[j], l->_value->_val)) {
        return t->_a_sets[i];
      }
    }
  }
  return NULL;
}

template<a>
static a _frozenGet(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  if (!l->_frozen) {
    printf("Error: unless frozen, must specify threshold set when getting from an lvar\n");
    exit(0);
  }
  if (!l->_value->_bot) {
    pthread_mutex_unlock(&(l->_mutex));
    return l->_value->_val; 
  }
  printf("Error: can't get bottom value\n");
  exit(0);
}
  

template<a>
static ActivationSet<a>* _get(Lvar<a>* l, ThresholdSet<a> * t) {
  pthread_mutex_lock(&(l->_mutex));

  #ifdef DEBUG
    if (l->_lattice != t->_lattice) {
      printf("Error: can't get() when Lvar doesn't have same lattice as threshold set.\n");
      exit(0);
    }
  #endif

  #ifdef CHECK
    if (l->_lattice != t->_lattice) {
      pthread_mutex_unlock(&(l->_mutex));
      return NULL;
    }
  #endif

  if (l->_frozen) {
    if (!l->_value->_bot) {
      pthread_mutex_unlock(&(l->_mutex));
      return activationSet(l->_lattice, 1){l->_value->_val}; 
    }
    pthread_mutex_unlock(&(l->_mutex));
    return NULL;
  }
    
  ActivationSet<a>* actReached = inst _thresholdReached<a>(l, t);
  while (actReached == NULL) {
    if (l->_frozen) {
      if (!l->_value->_bot) {
        pthread_mutex_unlock(&(l->_mutex));
        return activationSet(l->_lattice, 1){l->_value->_val}; 
      }
      pthread_mutex_unlock(&(l->_mutex));
      return NULL;
    }
    pthread_cond_wait(&(l->_cond), &(l->_mutex));
    actReached = inst _thresholdReached<a>(l, t);
  }
  pthread_mutex_unlock(&(l->_mutex));
  return actReached;
}

// takes an lvar and returns the exact value of the lvar as its result
// updates the lvar to be "frozen", preventing any further updates

template<a>
static a _freeze(Lvar<a>* l) {
  pthread_mutex_lock(&(l->_mutex));
  l->_frozen = 1;
  if (l->_value->_bot) { 
      printf("Error: can't freeze lvar with no value.\n");
      exit(0);
  } 
  a result = l->_value->_val;
  pthread_mutex_unlock(&(l->_mutex));
  return result;
}

// ***************************** testing functions ****************************

// must specify two example elements such that the first precedes
// the second in the lattice

template<a>
int _checkLeq(Lattice<a>* D, a repElemSmall, a repElemBig) { 
  int result = 1;
  if (!D->_leq(repElemSmall, repElemBig)) {
    printf("according to specified test values, leq(");
    D->_display(repElemSmall);
    printf(", ");
    D->_display(repElemBig);
    printf(") should return 1\n");
    result = 0;
  }
  return result;
}

// must specify two representative elements and their least upper bound,
// along with an equality function for the base type of the lattice

template<a>
int _checkLub(Lattice<a>* D, a rep1, a rep2, a expLub, int (*eq)()) {
  int result = 1;
  if (!eq(D->_lub(rep2, rep1), expLub)) {
    printf("lub(");
    D->_display(rep2);
    printf(", "); 
    D->_display(rep1);
    printf(") should return ");
    D->_display(expLub);
    printf("\n");
    result = 0;
  }
  if (!eq(D->_lub(rep1, rep2), expLub)) {
    printf("lub(");
    D->_display(rep1);
    printf(", "); 
    D->_display(rep2);
    printf(") should return ");
    D->_display(expLub);
    printf("\n");
    result = 0;
  }
  return result;
}

#endif // LVARS_H_
