abstract production leq
top::Expr ::= lattice::Expr val1::Expr val2::Expr
{

  propagate substituted;
  top.pp = pp"leq(${lattice.pp}, ${val1.pp}, ${val2.pp})";

  forwards to
  case lattice.typerep of
    pointerType(_, latticeType(_, t)) -> 
      leq_helper(ableC_Expr{$Expr{lattice}->_top, val1, val2)
    _ -> errorExpr([err(top.location, 
         "Must provide a lattice to use leq, not" ++
         showType(lattice.typerep) ++">")], location=top.location)
  end;
}

abstract production leq_helper
top::Expr ::= lattice::Expr top::Expr val1::Expr val2::Expr
{
  propagate substituted;
  top.pp = pp"leq(${lattice.pp}, ${val1.pp}, ${val2.pp})";

  forwards to
    ableC_Expr{
      match ($Expr{val2}) {
        $Expr{top} -> {1;}
        _ -> {
          match ($Expr{val2}) {
            $Expr{top} -> {0;}
            _ -> {$Expr{lattice}->_leq($Expr{val1}, $Expr{val2})
          }
        }
      }
    }

  end;
}

Problems: 
  + Can't match on top, since it isn't defined at compile time
    (string repr is just "(l)->_top")
  + Can't use regular equality, since it leads to incorrect results 
    w/ algebraic data types.
  + Could have user provide eq, but that would still involve them matching on 
    top
  + Can't just make top an internal flag, since programmer needs to be able to 
    return top in case of error in their lub
  + Programmers need top value to match type of values in lattice, regardless of 
    that type (to be able to return in lub)

Ideas:
  + Create a wrapper
 
   Top()
   Val(a)
   Bot()

   Needs to be different for every type user can throw at you so that multiple 
   lattice are possible... Maybe void pointer? Then create for each builtin type?

  + Lub returns a pair: (a, int); int indicates whether value is top.
    Kind of a pain for users to create an array/struct

  + Have lub return a value struct instead of a raw value; could create a new one
    with concrete syntax top, value(...), or bot

     + Can get rid of freeLattice()
     + Need to fix lattice constructor to not use top as base type
     + Need to fix newLatticeNoFree to get correct type
